---
import type { MarkdownHeading } from "astro";
import { siteConfig } from "../../config";
import { url } from "../../utils/url-utils";

interface Props {
	class?: string;
	headings: MarkdownHeading[];
}

let { headings = [] } = Astro.props;

let minDepth = 10;
for (const heading of headings) {
	minDepth = Math.min(minDepth, heading.depth);
}

const className = Astro.props.class;
const isPostsRoute = Astro.url.pathname.startsWith(url("/posts/"));

const removeTailingHash = (text: string) => {
	let lastIndexOfHash = text.lastIndexOf("#");
	if (lastIndexOfHash !== text.length - 1) {
		return text;
	}
	return text.substring(0, lastIndexOfHash);
};

interface HeadingNode {
	heading: MarkdownHeading;
	children: HeadingNode[];
}

function buildHeadingTree(headings: MarkdownHeading[]): HeadingNode[] {
	const root: HeadingNode[] = [];
	const stack: HeadingNode[] = [];

	headings.forEach((heading) => {
		const node: HeadingNode = { heading, children: [] };

		while (stack.length > 0 && stack[stack.length - 1].heading.depth >= heading.depth) {
			stack.pop();
		}

		if (stack.length === 0) {
			root.push(node);
		} else {
			stack[stack.length - 1].children.push(node);
		}

		stack.push(node);
	});

	return root;
}

const filteredHeadings = headings.filter((heading) => heading.depth < minDepth + siteConfig.toc.depth);
const headingTree = buildHeadingTree(filteredHeadings);

let h1Counter = 0;
---
{isPostsRoute &&
<table-of-contents class:list={[className, "group"]} data-min-depth={minDepth}>
    {headingTree.map((node) => {
        const renderNode = (n: HeadingNode): any => {
            const isH1 = n.heading.depth === minDepth;
            const hasChildren = n.children.length > 0;
            if (isH1) h1Counter++;
            const currentH1Count = h1Counter;
            
            return (
                <div class="toc-item" data-depth={n.heading.depth}>
                    <div class="toc-entry flex items-center gap-2 px-2 min-h-9 rounded-xl transition hover:bg-[var(--toc-btn-hover)] active:bg-[var(--toc-btn-active)] py-2 cursor-pointer">
                        <div class:list={["transition w-5 h-5 shrink-0 rounded-lg text-xs flex items-center justify-center font-bold",
                            isH1 ? "bg-[var(--toc-badge-bg)] text-[var(--btn-content)]" : "",
                            n.heading.depth === minDepth + 1 ? "ml-4" : "",
                            n.heading.depth === minDepth + 2 ? "ml-8" : ""
                        ]}>
                            {isH1 ? currentH1Count : 
                             n.heading.depth === minDepth + 1 ? <div class="transition w-2 h-2 rounded-[0.1875rem] bg-[var(--toc-badge-bg)]"></div> : 
                             <div class="transition w-1.5 h-1.5 rounded-sm bg-black/5 dark:bg-white/10"></div>}
                        </div>
                        <a href={`#${n.heading.slug}`} class:list={["flex-1 transition text-sm",
                            n.heading.depth === minDepth + 2 ? "text-30" : "text-50"
                        ]}>
                            {removeTailingHash(n.heading.text)}
                        </a>
                        {hasChildren && isH1 && (
                            <button class="toc-toggle-btn w-5 h-5 flex items-center justify-center rounded-md hover:bg-[var(--toc-btn-active)] transition" data-slug={n.heading.slug} aria-label="Toggle section">
                                <svg class="toc-toggle-icon w-3 h-3 text-[var(--primary)] transition-transform duration-200" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                    <polyline points="6 9 12 15 18 9"></polyline>
                                </svg>
                            </button>
                        )}
                    </div>
                    {hasChildren && (
                        <div class="toc-children collapsed" data-parent-slug={n.heading.slug}>
                            {n.children.map(child => renderNode(child))}
                        </div>
                    )}
                </div>
            );
        };
        return renderNode(node);
    })}
    <div id="active-indicator" style="opacity: 0" class:list={[{'hidden': headings.length == 0}, "-z-10 absolute bg-[var(--toc-btn-hover)] left-0 right-0 rounded-xl transition-all " +
        "group-hover:bg-transparent border-2 border-[var(--toc-btn-hover)] group-hover:border-[var(--toc-btn-active)] border-dashed"]}></div>
</table-of-contents>}

<style>
    .toc-children {
        overflow: hidden;
        transition: max-height 0.3s ease-out, opacity 0.2s ease-out;
        max-height: 1000px;
        opacity: 1;
    }
    
    .toc-children.collapsed {
        max-height: 0;
        opacity: 0;
    }
    
    .toc-toggle-icon.rotated {
        transform: rotate(180deg);
    }
</style>

<script>
class TableOfContents extends HTMLElement {
    tocEl: HTMLElement | null = null;
    visibleClass = "visible";
    observer: IntersectionObserver;
    anchorNavTarget: HTMLElement | null = null;
    headingIdxMap = new Map<string, number>();
    headings: HTMLElement[] = [];
    sections: HTMLElement[] = [];
    tocEntries: HTMLAnchorElement[] = [];
    active: boolean[] = [];
    activeIndicator: HTMLElement | null = null;
    collapsedState: Map<string, boolean> = new Map();
    storageKey = 'toc-collapsed-state';

    constructor() {
        super();
        this.observer = new IntersectionObserver(
            this.markVisibleSection, { threshold: 0 }
        );
    };

    markVisibleSection = (entries: IntersectionObserverEntry[]) => {
        entries.forEach((entry) => {
            const id = entry.target.children[0]?.getAttribute("id");
            const idx = id ? this.headingIdxMap.get(id) : undefined;
            if (idx != undefined)
                this.active[idx] = entry.isIntersecting;

            if (entry.isIntersecting && this.anchorNavTarget == entry.target.firstChild)
                this.anchorNavTarget = null;
        });

        if (!this.active.includes(true))
            this.fallback();
        this.update();
    };

    toggleActiveHeading = () => {
        let i = this.active.length - 1;
        let min = this.active.length - 1, max = -1;
        while (i >= 0 && !this.active[i]) {
            this.tocEntries[i].classList.remove(this.visibleClass);
            i--;
        }
        while (i >= 0 && this.active[i]) {
            this.tocEntries[i].classList.add(this.visibleClass);
            min = Math.min(min, i);
            max = Math.max(max, i);
            i--;
        }
        while (i >= 0) {
            this.tocEntries[i].classList.remove(this.visibleClass);
            i--;
        }
        if (min > max) {
            this.activeIndicator?.setAttribute("style", `opacity: 0`);
        } else {
            let parentOffset = this.tocEl?.getBoundingClientRect().top || 0;
            let scrollOffset = this.tocEl?.scrollTop || 0;
            let top = this.tocEntries[min].getBoundingClientRect().top - parentOffset + scrollOffset;
            let bottom = this.tocEntries[max].getBoundingClientRect().bottom - parentOffset + scrollOffset;
            this.activeIndicator?.setAttribute("style", `top: ${top}px; height: ${bottom - top}px`);
        }
    };

    scrollToActiveHeading = () => {
        if (this.anchorNavTarget || !this.tocEl) return;
        const activeHeading =
            document.querySelectorAll<HTMLDivElement>(`#toc .${this.visibleClass}`);
        if (!activeHeading.length) return;

        const topmost = activeHeading[0];
        const bottommost = activeHeading[activeHeading.length - 1];
        const tocHeight = this.tocEl.clientHeight;

        let top;
        if (bottommost.getBoundingClientRect().bottom -
            topmost.getBoundingClientRect().top < 0.9 * tocHeight)
            top = topmost.offsetTop - 32;
        else
            top = bottommost.offsetTop - tocHeight * 0.8;

        this.tocEl.scrollTo({
            top,
            left: 0,
            behavior: "smooth",
        });
    };

    update = () => {
        requestAnimationFrame(() => {
            this.toggleActiveHeading();
            this.scrollToActiveHeading();
        });
    };

    fallback = () => {
        if (!this.sections.length) return;

        for (let i = 0; i < this.sections.length; i++) {
            let offsetTop = this.sections[i].getBoundingClientRect().top;
            let offsetBottom = this.sections[i].getBoundingClientRect().bottom;

            if (this.isInRange(offsetTop, 0, window.innerHeight)
                || this.isInRange(offsetBottom, 0, window.innerHeight)
                || (offsetTop < 0 && offsetBottom > window.innerHeight)) {                    
                this.markActiveHeading(i);
            }
            else if (offsetTop > window.innerHeight) break;
        }
    };

    markActiveHeading = (idx: number)=> {
        this.active[idx] = true;
    };

    handleAnchorClick = (event: Event) => {
        const anchor = event
            .composedPath()
            .find((element) => element instanceof HTMLAnchorElement);

        if (anchor) {
            const id = decodeURIComponent((anchor as HTMLAnchorElement).hash?.substring(1));
            const idx = this.headingIdxMap.get(id);
            if (idx !== undefined) {
                this.anchorNavTarget = this.headings[idx];
            } else {
                this.anchorNavTarget = null;
            }
        }
    };

    isInRange(value: number, min: number, max: number) {
        return min < value && value < max;
    };

    loadCollapsedState = () => {
        try {
            const saved = localStorage.getItem(this.storageKey);
            if (saved) {
                const parsed = JSON.parse(saved);
                Object.entries(parsed).forEach(([slug, collapsed]) => {
                    this.collapsedState.set(slug, collapsed as boolean);
                });
            }
        } catch (e) {
            console.debug('Failed to load TOC collapsed state:', e);
        }
    };

    saveCollapsedState = () => {
        try {
            const state: Record<string, boolean> = {};
            this.collapsedState.forEach((collapsed, slug) => {
                state[slug] = collapsed;
            });
            localStorage.setItem(this.storageKey, JSON.stringify(state));
        } catch (e) {
            console.debug('Failed to save TOC collapsed state:', e);
        }
    };

    toggleCollapse = (slug: string) => {
        const children = this.querySelector(`.toc-children[data-parent-slug="${slug}"]`);
        const btn = this.querySelector(`.toc-toggle-btn[data-slug="${slug}"]`);
        const icon = btn?.querySelector('.toc-toggle-icon');
        
        if (children && btn && icon) {
            const isCollapsed = children.classList.contains('collapsed');
            
            if (isCollapsed) {
                children.classList.remove('collapsed');
                icon.classList.remove('rotated');
                this.collapsedState.set(slug, false);
            } else {
                children.classList.add('collapsed');
                icon.classList.add('rotated');
                this.collapsedState.set(slug, true);
            }
            
            this.saveCollapsedState();
        }
    };

    applyCollapsedState = () => {
        this.collapsedState.forEach((collapsed, slug) => {
            const children = this.querySelector(`.toc-children[data-parent-slug="${slug}"]`);
            const icon = this.querySelector(`.toc-toggle-btn[data-slug="${slug}"] .toc-toggle-icon`);
            
            if (children && icon) {
                if (collapsed) {
                    children.classList.add('collapsed');
                    icon.classList.add('rotated');
                } else {
                    children.classList.remove('collapsed');
                    icon.classList.remove('rotated');
                }
            }
        });
    };

    handleToggleClick = (event: Event) => {
        const target = event.target as HTMLElement;
        const btn = target.closest('.toc-toggle-btn');
        
        if (btn) {
            event.preventDefault();
            event.stopPropagation();
            const slug = btn.getAttribute('data-slug');
            if (slug) {
                this.toggleCollapse(slug);
            }
        }
    };

    connectedCallback() {
        const element = document.querySelector('.prose');
        if (element) {
            element.addEventListener('animationend', () => {
                this.init();
            }, { once: true });
        } else {
            console.debug('Animation element not found');
        }
    };

    init() {
        this.tocEl = document.getElementById(
            "toc-inner-wrapper"
        );

        if (!this.tocEl) return;

        this.tocEl.addEventListener("click", this.handleAnchorClick, {
            capture: true,
        });

        this.addEventListener('click', this.handleToggleClick);

        this.activeIndicator = document.getElementById("active-indicator");

        this.tocEntries = Array.from(
            document.querySelectorAll<HTMLAnchorElement>("#toc a[href^='#']")
        );

        if (this.tocEntries.length === 0) return;

        this.sections = new Array(this.tocEntries.length);
        this.headings = new Array(this.tocEntries.length);
        
        for (let i = 0; i < this.tocEntries.length; i++) {
            const id = decodeURIComponent(this.tocEntries[i].hash?.substring(1));
            const heading = document.getElementById(id);
            const section = heading?.parentElement;
            if (heading instanceof HTMLElement && section instanceof HTMLElement) {
                this.headings[i] = heading;
                this.sections[i] = section;
                this.headingIdxMap.set(id, i);
            }
        }
        this.active = new Array(this.tocEntries.length).fill(false);

        this.sections.forEach((section) =>
            this.observer.observe(section)
        );

        this.loadCollapsedState();
        this.applyCollapsedState();

        this.fallback();
        this.update();
    };

    disconnectedCallback() {
        this.sections.forEach((section) =>
            this.observer.unobserve(section)
        );
        this.observer.disconnect();
        this.tocEl?.removeEventListener("click", this.handleAnchorClick);
        this.removeEventListener('click', this.handleToggleClick);
    };
}

if (!customElements.get("table-of-contents")) {
    customElements.define("table-of-contents", TableOfContents);
}
</script>
